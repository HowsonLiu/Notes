# C/C++
---
## C与C++的区别
- C面向过程， C++面向对象
- struct在C中是结构体，只能存放变量。在C++中是类，可以有成员函数
- C++中有引用
- C的作用域只有局部与全局，C++有局部，类作用域以及命名空间
## 基本数据类型大小
|| 32位编译器 | 64位编译器 |
|:--:|:--:|:--:|
| **void\*** | **4字节** | **8字节** |
| char | 1字节 | 1字节 |
| short | 2字节 | 2字节 |
| int | 4字节 | 4字节 |
| uint | 4字节 | 4字节 |
| float | 4字节 | 4字节 |
| double | 8字节 | 8字节 |
| **long** | **4字节** | **8字节** |
| **ulong** | **4字节** | **8字节** |
| long long | 8字节 | 8字节 |
指针大小 = 编译器位数/8
## 内存对齐
### 一、定义
为了让内存存取更有效率而采用的一种编译阶段优化内存存取的手段
### 二、使用内存对齐的原因
- 不是所有的硬件平台都支持访问任意地址上的数据
- CPU读取未对齐的数据可能需要访问多次内存
### 三、编译器命令
```c++
#pragma pack(n) //指令在预处理阶段执行
```
手动设置内存对齐系数，n只能为1，2，4，8，16，默认为8
实际数据成员x对齐的大小：
> align(x) = min(sizeof(x), n)
### 四、对齐规则
1. 第一个成员变量放到offset为0的地方
2. 成员变量是基本数据类型x，则存储的起始位置为align(x)的整数倍
3. 成员变量是结构体y（其内部最大的基本数据类型成员变量m），则存储的起始位置为align(m)的整数倍
4. 成员变量是数组（类型为x），则存储的起始位置为align(x)的整数倍
5. 收尾，总大小为内部最大基本类型成员x的align(x)的整数倍
### 五、试试看
```c++
class A {
	char c;
	double d;
	char h;
	int i[4];
};
//sizeof(A) =  1 + (7) + 8 + 1 + (3) + 4*4 + (4) = 40
//#pragma pack(2) sizeof(A) = 1 + (1) + 8 + 1 + (1) + 4*4 = 28

class B{
	char c;
	int i;
	A a;
	char h;
};
// sizeof(B) = 1 + (3) + 4 + 40 + 1 + (7) = 56
// #pragma pack(2) sizeof(B) = 1 + (1) + 4 + 28 + 1 + (1) = 36
```
## C++关键字
### const
表明被修饰的变量或者对象值不能改变，改变会在编译时报错
- 修饰变量，则变量必须初始化
- 修饰对象，则对象不可变，且只能调用const的成员函数
- 修饰指针，根据const在*的位置：左定值，右定向
	```c++
	const int* p = &a; // (*p)不可变
	int* const p = &a; // p不可变
	const int* const p = &a; //p和(*p)都不可变
	```
- 修饰函数参数，一般仅用于指针和引用，值传递无意义
- 修饰函数返回值，在调用者看来使用返回值与使用一个const变量差不多
- 修饰类成员变量，则成员变量必须使用列表初始化
- 修饰类成员函数，则
	1. 该函数不能修改实例的值，即不能修改this指针
	2. 可以修改声明为mutable的成员变量
	3. 不能与static同时使用，因为static的成员函数没有this指针
	4. 有无const属于重载，默认调用无const版本的成员函数

## KMP算法
### 例子
在“ABCABCDEFGH”（source）中查找“ABCABB”（target），一般暴力的方法是通过i指针遍历source，j指针遍历target，不一致时同时回退i、j指针到起始位置的后一个位置解决。但是KMP算法是通过之前遍历时相同的信息，不回退i指针，适量回退j指针实现，以达到更好的效率
### 核心
- 在遍历中我们不难推出，任何时候source[0, i-1] = target[0, j-1]
- 我们需要尝试找出一个k，使得target[0, k-1] = target[j-k, j-1]
- 这样在source[i] != target[j]时，j可以通过回退到k避免再次比较重复部分
- 我们需要写出一个next数组，记录k在j不同取值时的值
- 显然这个next只跟target有关
### 代码
```c++
void getNext(const char* target, int size, int* next){
	if(!target || size < 0 || !next) return;
	next[0] = -1;
	int j = 0;
	int k = -1;
	while(j < size - 1){
		if(k == -1 || target[j] == target[k])
			next[++j] = ++k;
		else
			k = next[k];
	}
}
```
接下来，我们在普通的比较失败时
```c++
if(source[i] != target[j]) j = next[j]; // 不需要回溯i指针了
```