# 115 不同的子序列
[https://leetcode-cn.com/problems/distinct-subsequences/](https://leetcode-cn.com/problems/distinct-subsequences/)
## 解
二位数组dp，大小为`sn+1 * tn+1`，其中`dp[i][j]`表示`s[i:]`与`t[j:]`组成的子序列的个数

`s[i:]`表示从第`i`位到字符串末尾的子串，`0 <= i <= sn`，`i == sn`时为空串

递推公式：
```
dp[i][j] = dp[i+1][j+1] + dp[i+1][j]             s[i] == t[j]
         = dp[i+1][j]                            s[i] != t[j]
```
- 当`s[i] != t[j]`时
    无法选择，`s`串的第`i`位不可选，只能略过自己，数量为`dp[i+1][j]`
- 当`s[i] == t[j]`时
    可以选择。如果选择的话，则占用了t串的一位，此时他的数量为`dp[i+1][j+1]`；如果不选择的话，那不占用t串的一位，略过自己，数量为`dp[i+1][j]`。所以总数量为两者相加

边界条件：
```
dp[*][tn] = 1           空串是任何字符的子串，数量为1
dp[sn][*] = 0           非空串不可能是空串的子串，数量为0
dp[i][j] = 0  ilen < tlen   当s串比t串小时，不可能构成子串，数量为0
```

### 是否一定从后往前遍历
个人感觉不一定，从前往后遍历也能表达出这个递推公式，可能比较麻烦而已（未实验）

### 循环顺序
原来以为必须要从`j`遍历，但实际上没啥关系，只是理解起来比较顺而已，从递推公式也可以看出，只要遍历顺序是从后往前，`i`与`j`谁前谁后没有区别（已实验）

# 10 正则表达式匹配
[https://leetcode.com/problems/regular-expression-matching/](https://leetcode.com/problems/regular-expression-matching/)

## 解
首先需要定义match函数，比较方便
```c++
bool match(char lhs, char rhs) {
    return lhs == rhs || rhs == '.';
}
```
接着根据当前是否是`*`以及是否`match`两个维度，写出状态转移方程
||p[j] == *|p[j] != *|
|:---:|:---:|:---:|
|match|dp[i][j-2] \|dp[i-1][j] |dp[i-1][j-1]|
|not match|dp[i][j-2]|false|

`dp[i][j]`表示`s[:i-1]`与`p[:j-1]`能否匹配
- 当`p[j-1]`不为`'*'`时，如果匹配，则当前匹配的状态依赖`dp[i-1][j-1]`的状态；如果不匹配，则为`false`
- 当`p[j-1]`为`'*'`时，此时比较的双方为`s[i-1]`与`p[j-2]`
    - 如果不匹配，则只能放弃`x*`组合，依赖`dp[i][j-2]`的状态
    - 如果匹配，可以选择依赖`dp[i][j-2]`的状态，也可以选择舍弃掉s中匹配的那一个字符，状态倒退为`dp[i-1][j]`。由于我们是自底向上，因此可以实现递归匹配的效果

### 初始化状态
```
dp[0][0] = true
```
显然两个空字符是匹配的

### 循环
循环顺序无关系，但需要注意，p的循环从1开始，但是s的循环从0开始。原因是需要处理`''`与`'a*'`这种情况，也就是说`dp[0][2] = true`

### 注意
越界判断

# 42 接雨水
## 解
